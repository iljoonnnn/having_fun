{
  "hash": "bfb331ca3bff3453c77fc4fa5a1c0bf7",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: LS Bigdata School Homework 5\nauthor: iljoon\ndate: '2024-07-30'\ncategories:\n  - homework\n---\n\n# 분산 구할 때 n으로 나누기, n-1로 나누기 비교\n\n표본 분산 계산 시 왜 n-1로 나누는지 알아보도록 하겠습니다.\n\n균일분포 (3, 7)에서 20개의 표본을 뽑아서 분산을 2가지 방법으로 추정해보세요.\n\nn-1로 나눈 것을 s_2, n으로 나눈 것을 k_2로 정의하고, s_2의 분포와 k_2의 분포를 그려주세요! (10000개 사용) 각 분포 그래프에 모분산의 위치에 녹색 막대를 그려주세요. 결과를 살펴보고, 왜 n-1로 나눈 것을 분산을 추정하는 지표로 사용하는 것이 타당한지 써주세요!\n\n---\n\n# 패키지 불러오기.\n\n::: {#1037faa1 .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom scipy.stats import norm\nfrom scipy.stats import uniform\n```\n:::\n\n\n# 표본 분산 계산해보기\n\n::: {#d718cba3 .cell execution_count=2}\n``` {.python .cell-code}\nnp.random.seed(20240729)\nx = uniform.rvs(loc = 3, scale = 4, size = 20)\nx_bar = np.mean(x)\nsum((x - x_bar)**2) / (len(x)-1)\n# 1.669\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\nnp.float64(1.6697498189003381)\n```\n:::\n:::\n\n\n# 이론적인 분산 값\n\n::: {#d1f29ba6 .cell execution_count=3}\n``` {.python .cell-code}\nmy_var = uniform.var(loc = 3, scale = 4)\n# 1.333\n```\n:::\n\n\n# 몬테카를로 시뮬레이션을 이용해서 분산값 구하기.\n\n::: {#922fc1b8 .cell execution_count=4}\n``` {.python .cell-code}\nnp.random.seed(20240729)\nx = uniform.rvs(loc = 3, scale = 4, size = 20 * 10000)\nx.shape\nx = np.reshape(x, (-1, 20))\nx.shape\ns_2 = x.var(axis = 1, ddof = 1)  # n-1 으로 나누기.\nk_2 = x.var(axis = 1, ddof = 0) # n 으로 나누기.\n```\n:::\n\n\n# s_2 그래프 그리기\n\n::: {#fb821382 .cell execution_count=5}\n``` {.python .cell-code}\nplt.hist(s_2, bins = 40)\nplt.axvline(my_var, color = 'green', linestyle = 'dashed', linewidth = 2)\nplt.show()\nplt.clf()\n```\n\n::: {.cell-output .cell-output-display}\n![](hw5_files/figure-html/cell-6-output-1.png){width=575 height=411}\n:::\n\n::: {.cell-output .cell-output-display}\n```\n<Figure size 672x480 with 0 Axes>\n```\n:::\n:::\n\n\n# k_2 그래프 그리기\n\n::: {#8c5f4d13 .cell execution_count=6}\n``` {.python .cell-code}\nplt.hist(k_2, bins = 40)\nplt.axvline(my_var, color = 'green', linestyle = 'dashed', linewidth = 2)\nplt.show()\nplt.clf()\n```\n\n::: {.cell-output .cell-output-display}\n![](hw5_files/figure-html/cell-7-output-1.png){width=575 height=411}\n:::\n\n::: {.cell-output .cell-output-display}\n```\n<Figure size 672x480 with 0 Axes>\n```\n:::\n:::\n\n\ns_2 그래프가 이론적인 값에 더욱 가까운 것으로 확인 됨.\n\n# 이번엔 어떤 것이 이론적인 값에 가까웠는지 각각 경우마다 싸움을 붙여보겠다.\n\n::: {#33bf90d0 .cell execution_count=7}\n``` {.python .cell-code}\nresult = []\nfor i in range(10000):\n    if (s_2[i] - my_var)**2 < (k_2[i] - my_var)**2:\n        result.append(\"s_2 win\")\n    elif (s_2[i] - my_var)**2 > (k_2[i] - my_var)**2:\n        result.append(\"k_2 win\")\n# 10000개의 분산값을 각각 비교해서 이론적인 분산에 더 가까우면 그 방법을 1점 주는 반복문.\n```\n:::\n\n\n# 싸움 결과 시각화.\n\n::: {#08e93ef7 .cell execution_count=8}\n``` {.python .cell-code}\nsns.countplot(data = result)\nplt.show()\nplt.clf()\n# n-1이 더 효과 있따!!!\n```\n\n::: {.cell-output .cell-output-display}\n![](hw5_files/figure-html/cell-9-output-1.png){width=599 height=429}\n:::\n\n::: {.cell-output .cell-output-display}\n```\n<Figure size 672x480 with 0 Axes>\n```\n:::\n:::\n\n\n# 결론\nn-1을 사용하는 것이 이론적인 값에 더욱 도달하는 것을 살펴봤다.\n왜 분산값을 구할 때 n-1이 더 된 것인지지는 내일 설명을 들어야겠다.\n\n+코드 잘못된거 수정함_240730\n\n",
    "supporting": [
      "hw5_files"
    ],
    "filters": [],
    "includes": {}
  }
}